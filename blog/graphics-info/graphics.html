<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" href="../../styles.css"> </link>
        <link rel="stylesheet" href="../blog.css"> </link>
        <title> Graphics Questions </title>
        <meta name = "viewport" content = "width=1000"> </meta>
        <meta charset = "UTF-8"> </meta>
    </head>
    
    <body>
        <div class = "header" id = "header">
            <div class = "headerSection">
                <p> <a href = "../index.html" style = "text-decoration: none; color: white;"> Blog Home </a> </p>
            </div>
            <div class = "headerSection">
                <p> <a href = "../../index.html" style = "text-decoration: none; color: white;"> Home </a> </p>
            </div>
        </div>
        <div class = "content">
            <h1> Junior Graphics Engineer Interview Questions </h1>
            <p>
                Junior graphics engineer interviews require a lot more domain-specific knowledge than your typical junior software engineer interviews. I've failed many interviews because I didn't fully understand common graphics interview topics. So I made this page to include some common interview topics I encountered during my interview process. I'm not going to go super in depth on all topics on this page, but I will link to other resources that do go in depth. Not all these topics will come up, but it's good to have familiarity with all of the topics. If you're interested about my experience applying for graphics jobs, you can read about that <a class = "colorLink" href = "../job/job.html">here</a>.
            </p>


            <h2 class = "sectionHeader"> Math </h2>
            
            <p class = "subsectionHeader"> <b> Powers of 2 </b> </p>
            <div class = "subsectionContent">
                <p> 
                    Yes, really. I've been directly asked about them in at least 2<sup>1</sup> interviews.
                </p>
                <p>
                    I just know that 2<sup>4</sup> = 16, 2<sup>8</sup> = 256, and that I can multiply or divide by 2 to get whatever specific power of 2 I get asked to compute.
                </p>
                <div class = "links">
                    <a href = "https://en.wikipedia.org/wiki/Power_of_two#Table_of_values" target = "_blank"> Powers of 2 (Wikipedia) </a>
                </div>
            </div>


            <p class = "subsectionHeader"> <b> Hexadecimal </b> </p>
            <div class = "subsectionContent"> 
                <p> Like binary, but with 16 numbers. </p>
                <div class = "links">
                    <a href = "https://en.wikipedia.org/wiki/Hexadecimal" target = "_blank"> Hexadecimal (Wikipedia) </a>
                </div>
            </div>



            <p class = "subsectionHeader"> <b> Two's Compliment </b> </p>
            <div class = "subsectionContent">
                <p> To create a negative number in two's compliment, determine the binary representation of the positive number, flip the bits, and add 1. </p>
                <div class = "links">
                    <a href = "https://en.wikipedia.org/wiki/Two%27s_complement#From_the_ones'_complement" target = "_blank"> Two's compliment (Wikipedia) </a>
                </div>
            </div>


            <p class = "subsectionHeader"> <b> Matrices </b> </p>
            <div class = "subsectionContent">
                <p class = "noBottom"> Rotation matrix properties </p>
                <ul>
                    <li> Each column vector is normalized </li> 
                    <li> Dot product of 2 unique column vectors is 0 </li> 
                    <li> All column vectors are orthonormal to each other, form an orthonormal basis </li> 
                    <li> Inverse matrix is the transpose </li> 
                </ul>
                <p> Model matrix is model -> world space </p>
                <p> View matrix is world -> camera space </p>
                <p> Projection matrix applies perspective correction to the view frustum </p>
                <p> Multiplication order matters, typically we multiply by scale, then rotation, then translation. </p>
                <div class = "links">
                    
                    <a href = "https://en.wikipedia.org/wiki/Rotation_matrix" target = "_blank"> Rotation matrix (Wikipedia) </a>
                    <br/>
                    <a href = "http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/" target = "_blank"> Tutorial 3 : Matrices (OpenGL-tutorial) </a>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Ray Intersections </b> </p>
            <div class = "subsectionContent">
                <p> A ray is defined at <b>x = dt + o</b>, where x is position, d is direction, t is time/distance, o is origin. d and o are normalized. </p>

                <p class = "noBottom"> Sphere </p>
                <ul> 
                    <li> r<sup>2</sup> = dot(x - p, x - p) </li>
                    <ul> 
                        <li>r is the radius of the sphere</li> 
                        <li> p is the center</li> 
                    </ul>
                    <li> r<sup>2</sup> = dot(dt + o - p, dt + o - p) </li>
                    <li> r<sup>2</sup> = dot(dt + R, dt + R) </li>
                    <ul> 
                        <li> R = o - p </li>
                    </ul>
                    <li> r<sup>2</sup> = d<sup>2</sup> * t<sup>2</sup> + 2dRt + R<sup>2</sup> </li>
                    <li> 0 = d<sup>2</sup> * t<sup>2</sup> + 2d(o - p)t + (o - p)<sup>2</sup> - r<sup>2</sup> </li>
                    <li> 0 = At<sup>2</sup> + Bt + C </li>
                    <ul> 
                        <li> A = dot(d, d) </li>
                        <li> B = 2 * dot(d, o - p) </li>
                        <li> C = dot(o - p, o - p) - r<sup>2</sup></li>
                    </ul>
                    <li> Use quadratic equation to solve for real solutions of t. </li>
                    <ul> 
                        <li> Two solutions: two intersection points on the sphere, usually take the closer point </li>
                        <li> One solution: ray is tangent to the sphere </li>
                        <li> Zero solutions: no intersection point </li>
                    </ul>
                </ul>

                <p class = "noBottom"> Plane </p>
                <ul>
                    <li> 0 = dot(x - p, n) </li>
                    <ul> 
                        <li> p is a point on the plane </li>
                        <li> n is the plane's normal </li>
                    </ul>
                    <li> 0 = dot(dt + o - p, n)</li>
                    <li> 0 = dot(d, n) * t + dot(o - p, n)</li>
                    <li> -dot(o - p, n) / dot(d, n) = t </li>
                    <ul> 
                        <li> t is negative: the ray is facing away from the plane </li>
                        <li> dot(d, n) = 0: ray and plane are parallel </li>
                    </ul>
                </ul>
                <div class = "links">
                    <a href = "https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection" target = "_blank"> Ray-Sphere Intersection (Scratchapixel) </a>
                    <br/>
                    <a href = "https://courses.cs.washington.edu/courses/csep557/10au/lectures/triangle_intersection.pdf" target = "_blank"> Ray-triangle intersection (Brian Curless) </a>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Dot/Cross products </b> </p>
            <div class = "subsectionContent">
                <p class = "noBottom"> Dot product </p>
                <ul>
                    <li> The angle between two vectors </li>
                    <li> dot(a, b) = length(a) * length(b) * cos(theta) </li>
                    <li> For normalized vectors, the range of dot product is -1 to 1 </li>
                    <ul>
                        <li> dot = 1: parallel facing same way (0 degrees) </li>
                        <li> dot = 0: normal/orthogonal (90 degrees) </li>
                        <li> dot = -1: parallel, facing opposite (180 degrees) </li>
                        <li> <b>The dot product between two parallel vectors is -1 or 1.</b> (Most people just say 1 apparently) </li>
                    </ul>
                    <li> Dot product is used in the rendering equation, BRDFs, phong shading, determining angle between two vectors. </li>
                </ul>
                <p class = "noBottom"> Cross product </p>
                <ul> 
                    <li> AxB = vector that is orthogonal to A and B. </li>
                    <li> AxB = -(BxA) = (-A)xB </li>
                    <li> A.(AxB) = B.(AxB) = 0 </li>
                    <li> length(AxB) = area of the parallelogram created by A and B </li>
                    <li> Cross product is used to generate a camera basis, or to create a normal vector for a plane from 3 points. </li>
                </ul>
            </div>

            <p class = "subsectionHeader"> <b> Quaternions </b> </p>
            <div class = "subsectionContent">
                <p> Way to represent rotation with 4D numbers. </p>
                <div class = "links">
                    <a href = "https://wrf.ecse.rpi.edu/pmwiki/pmwiki.php/Research/Quaternions" target = "_blank"> Quaternions (W. Randolph Franklin) </a>
                    <!-- https://wrf.ecse.rpi.edu/pmwiki/Research/Quaternions -->
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Euler Angles </b> </p>
            <div class = "subsectionContent">
                <p> Simple way to represent rotation. Can run into Gimbal lock, better to use quaternions. </p>
                <div class = "links">
                    <a href = "https://mathworld.wolfram.com/EulerAngles.html" target = "_blank"> Euler Angles (Wolfram) </a>
                    <br/>
                    <a href = "https://en.wikipedia.org/wiki/Gimbal_lock" target = "_blank"> Gimbal lock (Wikipedia) </a>
                </div>
            </div>            

            <p class = "subsectionHeader"> <b> Barycentric Coordinates </b> </p>
            <div class = "subsectionContent">
                <p> Coordinate system where you represent a point on a triangle by the weighted sum of the triangle's vertices. </p>
                <div class = "links">
                    <a href = "https://en.wikipedia.org/wiki/Barycentric_coordinate_system" target = "_blank"> Barycentric Coordinates (Wikipedia) </a>
                </div>
            </div>            

            <p class = "subsectionHeader"> <b> Rendering Equation </b> </p>
            <div class = "subsectionContent">
                <img src = "https://wikimedia.org/api/rest_v1/media/math/render/svg/3955fb75fee8d1ace1e117f728dd33f919262b36" style = "width: 80%;"/>


                <p>
                    For each input direction wi, calculate the light absorbed (irradiance) by the surface along wi (Li * wi&#183;n), then multiply that value by the amount of the absorbed light that exits the surface (radiance) in the direction of wo (fr). Then, if the surface itself emits light, calculate the amount of radiance that leaves the surface along wo (Le) and add it to the previous sum. This is equal to the total amount of radiance that leaves the surface along wo (Lo).
                </p>

                <p> 
                    Why is irradiance = Li * wi&#183;n? Iradiance is flux per unit area. The radiance (Li) is the flux. To understand how the dot product give us 'per unit area', lets think about a flashlight. If you hold a flashlight directly above a table, a flashlight will form a circle on the table. As you tilt the flashlight so that it is at a 45 degree angle to the table, the circle will turn into an ellipse. The radiance in these two cases is the same, but the area covered by the light is more in the 45 degree case, so the irradiance is smaller. This effect is modeled with the dot product term. You can see this effect visually below.
                </p>

                <img src = "https://upload.wikimedia.org/wikipedia/commons/c/ca/Oswietlenie_lamberta.svg" style = "width: 400px;"/>


                <p> 
                    Rendering equation is impossible to solve exactly, so it has to be approximated. The basic rendering equation does not capture some rendering effects like subsurface scattering, transmission, and volumetric effects. However, the rendering equation can be modified to accomodate these effects by integrating over the whole sphere instead of the hemisphere.
                </p>


                <div class = "links">
                    <a href = "https://en.wikipedia.org/wiki/Rendering_equation" target = "_blank"> Rendering Equation (Wikipedia) </a>
                </div>
            </div> 




            <p class = "subsectionHeader"> <b> BXDF </b> </p>
            <div class = "subsectionContent">
                <p class = "noBottom"> Bidirectional X Distribution function, where X is </p>
                <ul class = "noTop"> 
                    <li> Reflectance </li>
                    <li> Transmission </li>
                    <li> Surface </li>
                    <li> Subsurface Scattering </li>
                </ul>

                <p> Takes in two inputs, light direction into a surface (wi), light direction out of the surface (wo). The output of a BXDF is the ratio of radiance to irradiance for the surface. You can also think of it as the amount of light absorbed along wi that is reflected out along wo, or the % chance that a ray coming in along wi will reflect out along wo. </p>

                <img src = "https://wikimedia.org/api/rest_v1/media/math/render/svg/49e75397f3740b44e763145f6c8c64578b2440e7" style = "width: 400px;"/>


                <p class = "noBottom"> Properties of BXDFs </p>
                <ul class = "noTop"> 
                    <li> All outputs are of the BXDF are non-negaive. </li>
                    <li> Helmholtz reciprocity, BXDF(wi, wo) = BXDF(wo, wi) </li>
                    <li> Conserves energy, integral of the BRDF is 1. </li>
                </ul>


                <p class = "noBottom"> Types of BXDFs </p>
                <ul class = "noTop"> 
                    <li> Lambertian </li>
                    <li> Disney Diffuse </li>
                    <li> Blinn-Phong </li>
                    <li> Cook-Torrance </li>
                </ul>

                <div class = "links">
                    <a href = "https://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function" target = "_blank"> BRDF (Wikipedia) </a>
                    <br/>
                    <a href = "https://en.wikipedia.org/wiki/Blinn–Phong_reflection_model" target = "_blank"> Blinn-Phong (Wikipedia) </a>
                    <br/>
                    <a href = "http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx" target = "_blank"> Cook-Torrance (Wikipedia) </a>
                    <br/>
                    <a href = "https://sakibsaikia.github.io/graphics/2019/09/10/Deriving-Lambertian-BRDF-From-First-Principles.html" target = "_blank"> Lambertian (Sakib Saikia) </a>
                    <br/>
                    <a href = "https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf" target = "_blank"> Disney Diffuse (Brent Burley) </a>
                </div>
            </div>


            <p class = "subsectionHeader"> <b> Sampling </b> </p>
            <div class = "subsectionContent">
                <p> In graphics, we have to approximate things, like the rendering equation. We use various sampling techniques to calculate the approximations. We are trying to avoid aliasing/jagged edges in the images we render, sampling helps to do that. </p>
                <div class = "links">
                    <a href = "http://web.cs.wpi.edu/~emmanuel/courses/cs563/S10/talks/wk3_p1_wadii_sampling_techniques.pdf" target = "_blank"> Sampling Techniques (Wadii Bellamine) </a>
                    <br/>
                    <a href = "https://www.cs.rpi.edu/~cutler/classes/advancedgraphics/F05/lectures/20_sampling_aliasing.pdf" target = "_blank"> Sampling, Aliasing, & Mipmaps (Barb Cutler) </a>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Importance Sampling </b> </p>
            <div class = "subsectionContent">
                <p> The reason that importance sampling is so important is due to the following observation: whether a given sample contributes 50% or 0.1% to the final sum, the time it takes to evaluate the function at the two sample points is the same. Because of this, we should spend more time evaluating areas of the interval that contribute significantly to the final sum, and less time on areas that do not contribute much. </p>
                <div class = "links">
                    <a href = "http://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Importance_Sampling.html" target = "_blank"> Importance Sampling (Pharr, Jakob, Humphreys) </a>
                    <br/>
                    <a href = "../sampling/sampling.html" target = "_blank"> Intro to Sampling (made by me!) </a>
                </div>
            </div>


            <h2 class = "sectionHeader"> Graphics Pipeline </h2>
            <p class = "subsectionHeader"> <b> Pipeline </b> </p>
            <div class = "subsectionContent">

                <ul> 
                    <li> Vertex shader </li>
                    <ul> 
                        <li> Runs per vertex/point in the mesh. Typically transform mesh vertices from model space to screen space. Vertex shaders predominently use the GPU's matrix/vector multiplication units. </li>
                    </ul>
                    <li> Optional Tessellation shader </li>
                    <ul> 
                        <li> Used to create subdivided/fine detailed geometry within an input triangle patch. </li>
                    </ul>
                    <li> Optional Geometry shader </li>
                    <ul> 
                        <li> Used to create new geometry, like shadow volumes. </li>
                    </ul>
                    <li> Clipping </li>
                    <ul> 
                        <li> Remove vertices that are outside of the 1x1x1 cube, add new vertices if neccesary. </li>
                    </ul>
                    <li> Primative Assembly </li>
                    <ul> 
                        <li> Turn vertices into shapes (triangles, points, lines) </li>
                    </ul>
                    <li> Face culling </li>
                    <ul> 
                        <li> Front face/back face culling. If triangles face away from the screen, they are likely behind triangles that face the camera, so we should ignore them. This means triangles have a winding order (CW or CCW). </li>
                    </ul>
                    <li> Rasterization </li>
                    <ul> 
                        <li> Takes the triangles and figures out which pixels are covered by the triangles. If doing MSAA, might take multiple samples per pixel to reduce jaggies. </li>
                    </ul>
                    <li> Optional Early depth test </li>
                    <ul> 
                        <li> Depth test fragment against previously written depth for the pixel. If current fragment will be behind what is currently there, ignore this fragment to save computation time. </li>
                    </ul>
                    <li> Fragment shader </li>
                    <ul> 
                        <li> Take interpolated vertex output data, use it as input to calculate the pixel's color. Typically lighting calculations are done here, and fragment shaders use a lot of texture lookups and ALUs. </li>
                    </ul>
                    <li> depth/stencil test/alpha blending </li>
                    <ul> 
                        <li> Write to render target if this fragment will be in front of what is currently there. Same for stencil testing, also need to do alpha blending. Typically, depth and stencil occur before fragment shading, but it's possible to change the depth of a fragment in a fragment shader which would force depth test afterwards. </li>
                    </ul>
                </ul>
                <div class = "links">
                    <a href = "https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview" target = "_blank"> Rendering Pipeline Overview (Khronos) </a>
                </div>
            </div>


            <p class = "subsectionHeader"> <b> TBDR </b> </p>
            <div class = "subsectionContent">
                <p> Tile Based Deferred Rendering. Vertices are binned into tiles, then each tile is rendered separately, which reduces memory bandwidth between pipeline stages. </p>
                <div class = "links">
                    <a href = "https://developer.apple.com/videos/play/wwdc2020/10602/" target = "_blank"> Harness Apple GPUs with Metal (Apple) </a>
                </div>
            </div>


            <h2 class = "sectionHeader"> CPU/GPU Architecture </h2>

            <p class = "subsectionHeader"> <b> Stack vs Heap </b> </p>
            <div class = "subsectionContent">
                <p class = "noBottom"> Stack </p>
                <ul>
                    <li> A sequential block of memory, basically an array. </li>
                    <li> There is a stack pointer that points to the top of the stack. </li>
                    <li> Stack allocation is very quick, because adding new memory to the stack just requires incrementing the stack pointer. Deallocation is the same. </li>
                    <li> Meant for 'temporary variables' that are locally scoped within a function that won't be needed after the function returns. </li>
                    <li> Compiler can make some optimizations to preallocate all stack memory for a function when it is called. </li>
                </ul>
                <p class = "noBottom"> Heap </p>
                <ul>
                    <li> A larger group of memory than the stack. </li>
                    <li> In the heap, the OS basically finds spot in the heap to fit the data, which can be a challenge for large data structures. </li>
                    <li> This can lead to gaps of unused memory, memory fragmentation. </li>
                    <li> It takes longer to allocate and deallocate memory in the heap because of this. </li>
                    <li> Data referenced by pointers is typically stored in the heap, pointers are usually on the stack. </li>
                    <li> Heap is for data that needs to persist beyond the lifetime of a function (pointers). </li>
                    <li> Heap is bigger than stack. </li>
                </ul>
                <div class = "links">
                    <a href = "https://www.geeksforgeeks.org/stack-vs-heap-memory-allocation/" target = "_blank"> Stack vs Heap Memory Allocation (GeeksforGeeks) </a>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Cache, Memory, Cache Line </b> </p>
            <div class = "subsectionContent"> 
                <p> When executing a function, the assembly instructions and data for that function are usually stored sequentially. In order to speed up execution, the OS will prefetch a section of code instructions and data surrounding the current instruction location and store it in the cache, which is a very small, very fast bit of memory that is close to the CPU. While executing the function, the CPU will check the cache to see if the next instruction/data is in the cache. If it is, there is no need to go back to main memory to fetch the data. However, if it is not in the cache, this is a cache miss, and the data must be fetched from a lower cache level or main memory. The cache line is the amount of data that is read into the cache aat once. Since the cache relies on things being sequential, data structures that aren't contiguous can have many cache misses, stuff like graphs, trees, linked lists. Arrays have relatively fewer cache misses, since data is stored sequentially. There are multiple levels of caches, L1 is the fastest. </p>
                <div class = "links">

                    <a href = "https://medium.com/software-design/why-software-developers-should-care-about-cpu-caches-8da04355bb8a" target = "_blank"> Why software developers should care about CPU caches (EventHelix) </a>
                    <br/>
                    <a href = "https://rastergrid.com/blog/gpu-tech/2021/01/understanding-gpu-caches/" target = "_blank"> Understanding GPU caches (Rastergrid) </a>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> GPU Architecture </b> </p>
            <div class = "subsectionContent"> 

                <p> Thread - single invocation of a shader </p>
                <p> SIMD group/Warp - a group of 32 threads. This size is fixed by the GPU. In a SIMD group, all threads are executed in parallel in at once on a single GPU core. </p>
                <p> Threadgroup/Wavefront - A group of threads that are dispatched to a GPU. The threadgroup size is typically set by the programmer. </p>
                <p> Thread masking - GPUs execute SIMD groups in parallel and in lock step. As an example, if there is an add instruction in a shader, the GPU will fetch the inputs to the add instruction all at once, and execute the add instruction all at once, and write the results all at once. This is very efficient, but causes an issue for threads with if statements and loops (divergent threads). This is because some threads will execute different instructions while other threads need to execute other instructions. To solve this, the GPU will execute both branches of the if statement for each thread. The GPU will use thread masking to ignore the writes to the registers for the threads that are not supposed to be executing the instructions. This is why if statements should generally be avoided in GPU code if possible. </p>
                <p> Command Buffer - Instructions for a GPU draw call are stored in a command buffer. Stuff like pipeline state, buffer bindings, rendering mode (triangles, points, lines). OpenGL/WebGL do not expose command buffers through their APIs, but they are first class citizens in Metal/Vulkan/other modern APIs. </p>
                <p> Command Queue - Command buffers are submitted to the command queue, which holds the command buffers for the draw calls. </p>
              
                <div class = "links">
                    <a href = "http://www.icl.utk.edu/~luszczek/teaching/courses/fall2016/cosc462/pdf/GPU_Fundamentals.pdf" target = "_blank"> GPU Fundamentals (Jeff Larkin) </a>
                    <br/>
                    <a href = "https://aschrein.github.io/jekyll/update/2019/06/13/whatsup-with-my-branches-on-gpu.html" target = "_blank"> What's up with my branch on GPU? (Anton Schrein) </a>
                    <br/>
                    <a href = "https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Cmd-Submiss/Cmd-Submiss.html" target = "_blank"> Command Organization and Execution Model (Apple) </a>
                </div>
            </div>


            <h2 class = "sectionHeader"> Rendering Techniques </h2>
            <p class = "subsectionHeader"> <b> Physically Based Rendering </b> </p>
            <div class = "subsectionContent"> 
                <p> Physically Based Rendering, a way to realistically compute the way light interacts with materials. PBR uses BRDFs to approximate the rendering equation, and is generally photorealistic. PBR models typically have a diffuse/albedo component, a specular/gloss component, a roughness, a metallness, and emmission components. Not all of the components correspond to exact photorealistic parameters, but the parameters are meant to be tweakable by artists. </p>
                <div class = "links">
                    <a href = "https://en.wikipedia.org/wiki/Physically_based_rendering" target = "_blank"> Physically based rendering (Wikipedia) </a>
                </div>
            </div>   

            <p class = "subsectionHeader"> <b> Forward Rendering </b> </p>
            <div class = "subsectionContent"> 
                <p> Typical way that the graphics pipeline works. Have some triangles, put them through the vertex shader, compute lighting in fragment shader, then write to frame buffer. You might use a depth buffer to stop a fragment from being drawn behind a pixel that has already been drawn. </p>
                <div class = "links"> 
                    <a href = "https://gamedevelopment.tutsplus.com/articles/forward-rendering-vs-deferred-rendering--gamedev-12342" target = "_blank"> Forward Rendering vs. Deferred Rendering (Brent Owens) </a>
                </div>
            </div> 

            <p class = "subsectionHeader"> <b> Deferred Rendering </b> </p>
            <div class = "subsectionContent"> 
                <p> While forward rendering works ok, it does not prevent the case where you compute lighting on a fragment that will later be overwritten by another fragment that is closer to the camera. This means that your lighting calculations for the first fragment are wasted (overdraw), which is inefficient. Deferred rendering tries to solve this by deferring lighting to a second compute pass after the triangles have all been rasterized. In deferred rendering, during the fragment shader, the shader writes the various material components to a G-buffer, which is a group of textures containing diffuse/specular/normal/depth information about the triangles. After rasterization, a second compute pass takes the G-buffer and computes lighting. This way lighting is only calculated on pixels that appear on screen. </p>
                <p> Deferred rendering has some drawbacks, it uses significantly more texture memory than forward rendering, it can't handle transparent materials well, and it can be difficult to do MSAA with it. </p>
                <div class = "links">
                    <a href = "https://en.wikipedia.org/wiki/Deferred_shading" target = "_blank"> Deferred Shading (Wikipedia) </a>
                </div>
            </div> 
                        
            <p class = "subsectionHeader"> <b> Visibility Buffer Rendering </b> </p>
            <div class = "subsectionContent"> 
                <p> Visibility buffer rendering solves some issues with deferred rendering. In visibility buffer rendering, the fragment shader writes the triangle/primitive id and draw call id to the visibility buffer. This means you only need a depth + visibility buffer, no G-buffer. Then, in the lighting compute pass, the primitive id and draw call id are used to fetch the MVP matrices and material information from a material buffer, which is then used for lighting. </p>
                <div class = "links">
                    <a href = "http://diaryofagraphicsprogrammer.blogspot.com/2018/03/triangle-visibility-buffer.html" target = "_blank"> Triangle Visibility Buffer (Wolfgang Engel) </a>
                </div>
            </div> 

            <p class = "subsectionHeader"> <b> Shadow Mapping </b> </p>
            <div class = "subsectionContent"> 
                <p> Shadow mapping is a real time shadow algorithm. A depth buffer is rendered from the camera's point of view, and from the light's point of view. Then, pairs of depth values are compared between the images to determine if the pixels should be in light or shadow. Cascaded shadow mapping creates multiple depth buffers from the light's point of view for different depth ranges away from the camera to improve the resolution of the shadows. </p>
                <div class = "links">
                    <a href = "https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping" target = "_blank"> Shadow Mapping (Learn OpenGL) </a>
                    <br/>
                    <a href = "https://docs.microsoft.com/en-us/windows/win32/dxtecharts/cascaded-shadow-maps" target = "_blank"> Cascaded Shadow Mapping (Microsoft) </a>
                </div>
            </div> 


            <p class = "subsectionHeader"> <b> Mipmapping </b> </p>
            <div class = "subsectionContent"> 
                <p> Mipmapping is the process of creating lower resolution version of textures. With each mip level, the resolution is cut in half (pixel count cut into a quarter). The new mipmap levels will take up 33% more memory of than original texture. Having mipmaps can reduce Moiré patterns, and can save on texture memory by loading a lower resolution version of a texture if that texture appears far away from the camera. </p>
                <div class = "links">
                    <a href = "https://en.wikipedia.org/wiki/Mipmap" target = "_blank"> Mipmap (Wikipedia) </a>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Tone Mapping </b> </p>
            <div class = "subsectionContent"> 
                <p> A way to approximate HDR content on an low dynamic range screen. </p>
                <div class = "links">
                    <a href = "https://en.wikipedia.org/wiki/Tone_mapping" target = "_blank"> Tone Mapping (Wikipedia) </a>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Bloom </b> </p>
            <div class = "subsectionContent"> 
                <p> A way to approximate the washed out/glow effect that bright lights cause on camera sensors. </p>
                <div class = "links">
                    <a href = "https://en.wikipedia.org/wiki/Bloom_(shader_effect)" target = "_blank"> Bloom (Wikipedia) </a>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Ray Tracing </b> </p>
            <div class = "subsectionContent"> 
                <p> A technique to create images by tracing light paths through a scene. </p>
                <div class = "links">
                    <a href = "https://en.wikipedia.org/wiki/Ray_tracing_(graphics)" target = "_blank"> Ray tracing (Wikipedia) </a>
                </div>
            </div>


            <h2 class = "sectionHeader"> C++/OS stuff </h2>
            <p class = "subsectionHeader"> <b> Virtual Functions </b> </p>
            <div class = "subsectionContent"> 
                <p> Polymorphic classes are allowed to have virtual functions, which allow the child classes to implement different versions of the function for each object. The program will determine which virtual function to execute for the object at runtime. classes with virtual functions will get an additional void* vptr member (increasing the object size) pointing to the vtable. The vtable is essentially a list of the object's virtual function address. Pure virtual functions are marked with = 0 and they must be implemented by the subclass. </p>
                <div class = "links">
                    <a href = "https://www.geeksforgeeks.org/virtual-functions-and-runtime-polymorphism-in-c-set-1-introduction/" target = "_blank"> Virtual Functions and Runtime Polymorphism in C++ (GeeksforGeeks) </a>
                    <br/>
                    <a href = "https://www.geeksforgeeks.org/virtual-function-cpp/" target = "_blank"> Virtual Function in C++ (GeeksforGeeks) </a>
                    <br/>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Pointer vs Reference </b> </p>
            <div class = "subsectionContent">
                <p class = "noBottom"> Pointer </p>
                <ul> 
                    <li> Pointer is int* </li>
                    <li> Can point to a single object or an array of objects </li>
                    <li> Could be null, could be void* </li>
                </ul>

                <p class = "noBottom"> Reference </p>
                <ul> 
                    <li> Reference is int& </li>
                    <li> Only points to a single object </li>
                    <li> Will not be null, will not be void& </li>
                </ul>

                <div class = "links"> 
                    <a href = "https://www.geeksforgeeks.org/pointers-vs-references-cpp/" target = "_blank"> Pointer vs Reference (GeeksforGeeks) </a>
                </div>
            </div>


           <p class = "subsectionHeader"> <b> Templated Classes </b> </p>
            <div class = "subsectionContent">
                <p> Templated classes allow you to write generic code/container classes. However, each new use of the class needs to be compiled individually, which can increase compile time and binary size. They can also be annoying to debug on old versions of C++. </p>
                <div class = "links"> 
                    <a href = "https://www.geeksforgeeks.org/templates-cpp/" target = "_blank"> Templates in C++ (GeeksforGeeks) </a>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Static </b> </p>
            <div class = "subsectionContent">
                <p> A static variable in a class is a shared between all objects of that class, they can all access and modify it. </p>
                <div class = "links"> 
                    <a href = "https://www.geeksforgeeks.org/static-keyword-cpp/" target = "_blank"> Static Keyword in C++ (GeeksforGeeks) </a>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Size, Padding, Alignment </b> </p>
            <div class = "subsectionContent">
                <p> The size of an object is important, and there is a difference between the padding, alignment, and size of an object. An empty object without a virtual function will have a size of 1 byte, with a virtual function is 4 bytes. </p>
                <div class = "links"> 
                    <a href = "https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/" target = "_blank"> Structure Member Alignment, Padding and Data Packing (GeeksforGeeks) </a>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Mutex and Semaphore </b> </p>
            <div class = "subsectionContent">
                <p> Used for multithreaded programming and locking to prevent race conditions. Mutexes generally allow one thread to access a resource, while a semaphore can allow multiple threads to access a resource. </p>
                <div class = "links"> 
                    <a href = "https://www.geeksforgeeks.org/mutex-vs-semaphore/" target = "_blank"> Mutex vs Semaphore (GeeksforGeeks) </a>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Paging </b> </p>
            <div class = "subsectionContent">
                <p> Paging allows you to have 'contiguous' memory that is not actually contiguous. This is nice for heap memory, which can become fragmented. </p>
                <div class = "links"> 
                    <a href = "https://www.geeksforgeeks.org/paging-in-operating-system/" target = "_blank"> Paging in Operating System (GeeksforGeeks) </a>
                </div>
            </div>
            <h2 class = "sectionHeader"> Data Structures/Algorithms </h2>
            <p class = "subsectionHeader"> <b> DFS/BFS </b> </p>
            <div class = "subsectionContent">
                <p> Depth First Search and Breadth First Search. The DFS/BFS algorithms are pretty simple, and they come up occasionally. The iterative cases are very similar to each other. The iterative DFS is usually better than recursive, since large trees could cause the program to run out of stack memory. </p>
                <div class = "codeBlock">
                    <code> 
                        <pre>
 //The main difference between dfsIterative and bfsIterative is one
 //function uses a stack while the other uses a queue.
 void dfsIterative(TreeNode* root) {
     if (root == NULL) {
         return;
     }
     <b>stack s;
     s.push(root);</b>
 
     while (!s.empty()) {
         TreeNode* n = <b>s.pop();</b>
         process(n);
         for (TreeNode* child: n->children) {
             if (child != NULL) {
                 s.<b>push</b>(child);
             }
         }
     }
 }
 
 void bfsIterative(TreeNode* root) {
     if (root == NULL) {
         return;
     }     
     <b>queue q;
     q.enqueue(root);</b>
 
     while (!q.empty()) {
         TreeNode* n = <b>q.dequeue();</b>
         process(n);
         for (TreeNode* child: n->children) {
             if (child != NULL) {
                 q.<b>enqueue</b>(child);
             }
         }
     }
 }
 
 //DFS can also be done recursive
 void dfsRecursive(TreeNode* root) {
     if (root == NULL) {
         return;
     }
 
     process(root);
     for (TreeNode* child: root->children) {
         dfsRecursive(child);
     }
 }</pre> </code>
                </div>
                <br/>

                <div class = "links"> 
                    <a href = "https://www.geeksforgeeks.org/bfs-vs-dfs-binary-tree/" target = "_blank"> BFS vs DFS for Binary Tree (GeeksforGeeks) </a>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Reverse Linked List </b> </p>
            <div class = "subsectionContent">
                <p> Been asked this question twice, its pretty simple to do in linear time. </p>
                <div class = "codeBlock">
                    <code> 
                        <pre>
 ListNode* reverse(ListNode* head) {
     ListNode* currentNode = head;
     ListNode* nextNode = head->next;
     currentNode->next = NULL;
 
     while (nextNode != NULL) {
         ListNode* newNextNode = nextNode->next;
         nextNode->next = currentNode;
         currentNode = nextNode;
         nextNode = newNextNode;
     }
     
     //new head of the list
     return currentNode;
 }</pre>
                    </code>
                </div>
                <br/>

                <div class = "links"> 
                    <a href = "https://www.geeksforgeeks.org/reverse-a-linked-list/" target = "_blank"> Reverse a linked list (GeeksforGeeks) </a>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Spacial Data Structures </b> </p>
            <div class = "subsectionContent">
                <p> Used to query spacial data in sub-linear time. Still takes linear time to build spacial data structures. </p>
                <p> k-d tree - partition data along alternating dimensions </p> 
                <p> Bounding Volume Hierarchy - Create bounding boxes around objects, then more bounding boxes around groups of objects </p> 
                <p> Binary Space Parition - Partition data using planes </p> 
                <p> Octree - tree where each node has 8 children </p> 
                <div class = "links">
                    <a href = "https://en.wikipedia.org/wiki/K-d_tree" target = "_blank"> k-d tree (Wikipedia) </a>
                    <br/>
                    <a href = "https://en.wikipedia.org/wiki/Bounding_volume_hierarchy" target = "_blank"> BVH (Wikipedia) </a>
                    <br/>
                    <a href = "https://en.wikipedia.org/wiki/Binary_space_partitioning" target = "_blank"> BSP (Wikipedia) </a>
                    <br/>
                    <a href = "https://en.wikipedia.org/wiki/Octree" target = "_blank"> Octree (Wikipedia) </a>
                    <br/>
                </div>


            </div>


            <p class = "subsectionHeader"> <b> Linked List vs Arrays </b> </p>
            <div class = "subsectionContent">
                <p class = "noBottom"> Linked List </p>
                <ul> 
                    <li> A chain of nodes that contain pointers to the next and previous nodes in the list. </li>
                    <li> Very quick to add, remove, and insert elements into the list. </li>
                    <li> Generally takes linear time to find the nth element in the list. </li>
                    <li> Won't have the best cache performance, since list nodes aren't neccesarily next to each other in memory. </li>
                </ul>

                <p class = "noBottom"> Array </p>
                <ul> 
                    <li> Collection of elements in a continous block of memory. </li>
                    <li> Very quick to index into the array to the nth element. </li>
                    <li> Can't resize the array without creating a new array and copying data over. </li>
                    <li> Generally takes linear time to remove an element from an array. </li>
                    <li> Typically has good cache performance since data is contiguous. </li>
                </ul>

                <div class = "links"> 
                    <a href = "https://www.geeksforgeeks.org/linked-list-vs-array/" target = "_blank"> Linked List vs Array (GeeksforGeeks) </a>
                </div>
                
            </div>

            <h2 class = "sectionHeader"> Other stuff </h2>
            <p class = "subsectionHeader"> <b> Cloth Simulation </b> </p>
            <div class = "subsectionContent"> 
                <p> Common cloth simulation methods use mass/spring. A bunch of cloth vertices are connected by springs that keep the vertices in place. There are structural springs, which are for adjacent vertices in the face. Shear vertices are for non-adjacent vertices in a face. Flexion/bend vertices are 'two hops' away. </p>

                <div class = "links"> 
                    <a href = "https://www.cs.umd.edu/class/fall2019/cmsc828X/LEC/Wei_Cloth.pdf" target = "_blank"> Cloth Simulation (Zhen Wei) </a>
                    <br/>
                    <a href = "https://docs.blender.org/manual/en/latest/physics/cloth/introduction.html" target = "_blank"> Introduction to Cloth (Blender) </a>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Subdivision Surfaces </b> </p>
            <div class = "subsectionContent"> 
                <p> Process of smoothing out a surface and adding more geometry. Most common technique is Catmull-Clark. Typically we use half-edge data structures to represent meshes that we want to subdivide. </p>
                <div class = "links">
                    <a href = "https://en.wikipedia.org/wiki/Subdivision_surface" target = "_blank"> Subdivision Surface (Wikipedia) </a>
                    <br/>                    
                    <a href = "https://en.wikipedia.org/wiki/Catmull–Clark_subdivision_surface" target = "_blank"> Catmull-Clark (Wikipedia) </a>
                    <br/>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Fluid Simulation </b> </p>
            <div class = "subsectionContent"> 
                <p> Fluid simulation involves solving the Navier-Stokes equation, which model forces like gravity, pressure, viscosity, etc. Two main types of fluid: Eulerian and Lagrangian. Lagrangian is about tracking individual particles in the simulation, while Eulerian is about tracking the flow of particles through a specific location, rather than individual particles. Lagrangian is a particle based approach (mesh free), while Eulerian is a grid/mesh based approach.  </p>
                <div class = "links"> 
                    <a href = "https://www.cs.rpi.edu/~cutler/classes/advancedgraphics/S09/lectures/08_fluid_simulation.pdf" target = "_blank"> Navier-Stokes & Flow Simulation (Barb Culter) </a>
                    <br/>
                    <a href = "https://en.wikipedia.org/wiki/Lagrangian_and_Eulerian_specification_of_the_flow_field" target = "_blank"> Eulerian vs Lagangian (Wikipedia) </a>
                    <br/>
                    <a href = "https://en.wikipedia.org/wiki/Navier–Stokes_equations" target = "_blank"> Navier-Stokes equations (Wikipedia) </a>
                </div>
            </div>

            <p class = "subsectionHeader"> <b> Integration Methods </b> </p>
            <div class = "subsectionContent"> 
                <p> Explicit Euler, Implicit Euler, and Runge-Kutta (RK4) are common integration methods. Euler is typically unstable on forces that vary with time/distance/position. RK4 is more stable, but it's more complicated. </p>
                <div class = "links"> 
                    <a href = "https://www.cs.umd.edu/class/fall2019/cmsc828X/LEC/Wei_Cloth.pdf" target = "_blank"> Cloth Simulation (Zhen Wei) </a>
                </div>
            </div>
            
            <p class = "subsectionHeader"> <b> Apple Silicon </b> </p>
            <div class = "subsectionContent">
                <p> If you want to work for Apple (or are just interested), you'll want to be familiar with Apple Silicon. </p>
                <div class = "links">
                    <a href = "https://developer.apple.com/videos/play/tech-talks/10859" target = "_blank"> Tailor your Metal apps for Apple M1 (Apple) </a>
                    <br/>
                    <a href = "https://developer.apple.com/videos/play/wwdc2020/10631/" target = "_blank"> Bring your Metal app to Apple silicon Macs (Apple) </a>
                    <br/>
                    <a href = "https://developer.apple.com/videos/play/wwdc2020/10632/" target = "_blank"> Optimize Metal Performance for Apple silicon Macs (Apple) </a>
                    <br/>
                    <a href = "https://developer.apple.com/videos/play/tech-talks/10858/" target = "_blank"> Discover Metal enhancements for A14 Bionic (Apple) </a>
                    <br/>
                    <a href = "https://developer.apple.com/videos/play/wwdc2019/601/" target = "_blank"> Modern Rendering with Metal (Apple) </a>
                </div>

            </div>

            <p class = "subsectionHeader"> <b> Node-Based Graphs </b> </p>
            <div class = "subsectionContent"> 
                <p> Lots of rendering/VFX stuff uses node graphs to represent shaders/render passes/materials/etc. </p>
                <div class = "links">
                    <a href = "https://unity.com/shader-graph" target = "_blank"> Shader Graph (Unity) </a>
                    <br/>
                    <a href = "https://unity.com/visual-effect-graph" target = "_blank"> Visual Effect Graph (Unity) </a>
                    <br/>
                    <a href = "https://levelup.gitconnected.com/organizing-gpu-work-with-directed-acyclic-graphs-f3fd5f2c2af3" target = "_blank"> Organizing GPU Work with Directed Acyclic Graphs (Pavlo Muratov) </a>
                    <br/>
                    <a href = "https://apoorvaj.io/render-graphs-1/" target = "_blank"> Render graphs (Apoorva Joshi) </a>
                    <br/>
                    <a href = "http://simonstechblog.blogspot.com/2019/07/render-graph.html" target = "_blank"> Render Graph (Simon's tech blog) </a>
                </div>
            </div>
        </div>
        
        <!--<script type = "text/javascript" src = "scripts/header.js"> </script>-->
        <div class = "footer">
            <p> :) </p>
            <a href = "index.html"> <img src = "pictures/logo-white.png"> </img> </a>
            <div class = "linkBox">
                <a href = "../../index.html"> Home </a>
            </div>
        </div>
        <script type = "text/javascript" src = "../../scripts/footer.js"> </script>
        
        
    </body>
</html>


<!--
 
 -->
