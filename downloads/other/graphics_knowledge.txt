PBR
	Physically Based Rendering
	A way to realistically render the way light interacts with materials
	Generally photorealistic
	Used to approximate BRDFs and the rendering equation
	Some inputs of PBR
		Albedo/Diffuse
		Specular/gloss
		Reflectivity
		Metalness
		Emission
	PBR materials will have a diffuse portion and specular portion, materials that are shiny
	and have specular highlights will have a stronger specular portion.



BRDF
	bidirectional reflectance distribution function
	two inputs
		direction to light (wl)
		direction to camera (wc)
		surface normal is also needed
		the input directions have two angles definded around the normal
	output is the ratio of radiance to irradiance
	radiance is 'light out of the surface'
	irradiance is 'light into the surface'

	BRDF for a diffuse surface is constant

	Most physical materials are isotropic, the direction you view them at does not change the
	material properties, f(wl, wc) = f(wc, wl). This is called Helmholtz reciprocity.

	anisotropic materials do not obey Helmholtz reciprocity, which isotropic materials do.



rotation matrix properties
	three column vectors form an orthonormal basis
		two vectors dotted with each other = 0
		vector dotted with itself = 1
	inverse of matrix = transpose of matrix
	determinant = 1



SIMD
	Single Instruction Multiple Data
	Idea is that you can split up and parallelize computations
	GPUs do this all the time
	parallel CPU algorithms, multithreads
	Example:
		c[x] = a[x] + b[x]
		a and b are arrays of floats, want to add them together
		this can be parallelized
	Used in graphics/compute tasks/computer vision



deferred rendering
	screen space rendering algorithm
	two render passes
		first pass you render color, depth, normal, etc to separate textures
			this pass does not include any lighting computation
		second render pass combines the render textures together and performs
		lighting calculations on each pixel of the textures
	
	deferred rendering is more efficient because it does not spend time computing
	lighting in the fragment shader for pixels that will not be shown on screen 
	because they are occluded by other geometry.

	isnt good for transparent materials, uses up more buffer space than forward rendering



distance to a plane
	dist = |ax + by + cz + d| / sqrt(a^2 + b^2 + c^2)
	a,b,c,d - paramaters of plane (ax + by + cz + d = 0)
	x,y,z - point in space

	or 

	dist = (x - p).n / (n.n)
	x - point in space
	p - point on plane
	n - normal of plane

	How you derive the second equation:

	x = o - nt 
	//ray, direction of the ray is the negative normal, bc we want the smallest distance
	
	0 = (x - p).n 
	//plane

	(o - nt - p).n = 0
	(o - p).n - n.nt = 0
	(o - p).n = (n.n)t
	t = dist = (x - p).n / (n.n)	

	can determine if point is above or below the plane by removing the abs in the equation.
	Also, if you know the normal of the plane and a point on the plane, just take a vector from
	plane to point, dot with the normal, it the result is positive, above the plane, if negative, 
	below the plane.



Ray-primitive intersection equations
	Ray-sphere
		(x - p)^2 = r^2
		x = point in space
		p = center
		r = radius

		x = o + dt
		x = point in space
		o = ray origin
		d = ray direction
		t = time parameter, t/length(d) = distance from origin

		(o + dt - p)^2 = r^2
		o^2 + odt - po + odt + dt ^ 2 - pdt - po - pdt + p^2 = r^2

		o.o - 2p.o + 2o.dt + t2d.d - 2p.dt + p.p = r^2

		((d.d) * t^2) + (2(o.d - p.d) * t) + (o.o - 2p.o + p.p - r^2) = 0

		at^2 + bt + c = 0
		a = d.d
		b = 2 * (o - p).d
		c = (o - p).(o - p) - r^2

		solve quadratic for t.

	Ray-plane
		(x - p).n = 0
		x = point in space
		p = point on plane
		d = plane normal

		x = o + dt
		x = point in space
		o = ray origin
		d = ray direction

		(o + dt - p).n = 0

		(o - p).n + d.nt = 0

		(o - p).n = -d.nt
		t = -(o - p).n / d.n = (p - o).n / d.n



dot product
	a.b = length(a) * length(b) * cos(theta)
	if the two vectors are unit vectors (length = 1), a.b = cos(theta), range of [-1, 1]
	dot product relates to the angle between two vectors.
	
	theta > 90    ->    a.b is positive
	theta < 90    ->    a.b is negative
	theta = 90    ->    a.b is 0

	Two parallel unit vectors will have a dot product of 1 or -1, depending on the direction
	the vectors are pointing.

	If two vectors are normal/orthogonal, the dot product is 0.

	Dot product applications:
		equation of a plane (x - p).n = 0
		lighting calculations for diffuse surfaces
		reflection vector calculation



cross product
	Given two vectors, A and B, the cross product is a vector C that is orthogonal to A and B.
	AxB = C
	BxA = -C
	AxB = -BxA
	A.C = B.C = 0
	length(C) = area of the parallelogram generated by A and B

	Cross product applications:
		Generating orthonormal camera basis from a camera lookAt vector
			forward = normalize(camera.lookTo - camera.position)
			left = cross(y-axis, forward)
			up = cross(left, forward)
			//need to check this
		Generating normal for a plane from 3 points
			Points A, B, C
			n = cross(A - B, C - B)



powers of 2
	2^4 = 16
	2^5 = 32
	2^6 = 64
	2^7 = 128
	2^8 = 256
	2^9 = 512



hexadecimal
decimal = hexadecimal
	0-9 = 0-9
	10  = A
	11  = B
	12  = C
	13  = D
	14  = E
	15  = F



two's compliment
	how we represent negative numbers in binary
	two's compliment uses signed integers/doubles.
	if we only need to represent positive numbers, we can use an unsigned number.
	unsigned char = [0, 255]
	signed char = [-127, 128]
	to represent a negative number, take its positive binary representation, flip all the bits, and add 1.
	-a = ~a + 1

	example:
		-20 in binary
		0001 0100  (20 in binary)              (14 in hex)
		1110 1011  (~20 in binary)             (EB in hex)
		1110 1100  (~20 + 1 = -20 in binary)   (EC in hex)

		we can confirm that this is correct by adding -20 + 20 to see if it is 0

        1111 1
		0001 0100
		1110 1100 +
		0000 0000



rendering equation
	https://en.wikipedia.org/wiki/Rendering_equation

quaternions
	https://wrf.ecse.rpi.edu/pmwiki/pmwiki.php/Research/Quaternions

templated classes
	http://www.cplusplus.com/doc/oldtutorial/templates/

rendering pipeline
	https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview

shadow mapping
	https://en.wikipedia.org/wiki/Shadow_mapping

pointer vs reference
	difference
	why use
	https://www.geeksforgeeks.org/pointers-vs-references-cpp/

stack vs heap
	which is bigger
	why use each
	https://www.geeksforgeeks.org/stack-vs-heap-memory-allocation/

static
	https://www.geeksforgeeks.org/static-keyword-cpp/

virutal function
	odo they have to be implemented
	https://stackoverflow.com/questions/2609299/use-cases-of-pure-virtual-functions-with-body

bitwise operators
	https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/

call stack
	https://www.bogotobogo.com/cplusplus/stackunwinding.php
compiler
	turns .cpp into .o files
	test files turn into machine code
linker
	connects .o files, other libraries together to make an executable
buffer overflow
	https://en.wikipedia.org/wiki/Buffer_overflow


command queue command buffer
threadgroups
padding, size of various data types
isotropic materials
hashmap multithreaded
dfs vs bfs
cache, memory, cache line
render target size
types of shaders
	vertex
	fragment/pixel
	compute/kernel
	tesellation

Tile rendering
importance sampling

tesselation vs geometry shader
shadow maps
cascaded shadow maps
forward plus rendering






